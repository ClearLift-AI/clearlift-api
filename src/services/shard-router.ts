/**
 * Shard Router Service
 *
 * Routes database queries to the correct D1 shard based on organization ID.
 * Uses consistent hashing for deterministic shard assignment.
 *
 * Architecture:
 * - Central DB (DB) stores: users, sessions, orgs, connections, shard_routing
 * - Sharded DBs (SHARD_0-15) store: campaigns, metrics, pre-aggregations
 *
 * @example
 * ```typescript
 * const router = new ShardRouter(env.DB, getShards(env));
 * const shard = await router.getShardForOrg(orgId);
 * const campaigns = await shard.prepare('SELECT * FROM google_campaigns WHERE organization_id = ?')
 *   .bind(orgId).all();
 * ```
 */

// D1Database type comes from worker-configuration.d.ts (generated by wrangler types)

const NUM_SHARDS = 16;  // Max shards (start with 4, scale to 16)
const ACTIVE_SHARDS = 4;  // Currently active shards (0-3)

export interface ShardEnv {
  SHARD_0?: D1Database;
  SHARD_1?: D1Database;
  SHARD_2?: D1Database;
  SHARD_3?: D1Database;
  SHARD_4?: D1Database;
  SHARD_5?: D1Database;
  SHARD_6?: D1Database;
  SHARD_7?: D1Database;
  SHARD_8?: D1Database;
  SHARD_9?: D1Database;
  SHARD_10?: D1Database;
  SHARD_11?: D1Database;
  SHARD_12?: D1Database;
  SHARD_13?: D1Database;
  SHARD_14?: D1Database;
  SHARD_15?: D1Database;
}

/**
 * Get available shards from environment
 */
export function getShards(env: ShardEnv): D1Database[] {
  const shards: D1Database[] = [];
  for (let i = 0; i < NUM_SHARDS; i++) {
    const shard = env[`SHARD_${i}` as keyof ShardEnv];
    if (shard) {
      shards.push(shard);
    }
  }
  return shards;
}

/**
 * Shard routing information
 */
export interface ShardRoutingInfo {
  organization_id: string;
  shard_id: number;
  created_at: string;
  migrated_at: string | null;
  verified_at: string | null;
  data_size_bytes: number;
  campaign_count: number;
  metrics_row_count: number;
}

export class ShardRouter {
  private shardCache = new Map<string, number>();
  private activeShardCount: number;

  constructor(
    private centralDb: D1Database,
    private shards: D1Database[]
  ) {
    this.activeShardCount = Math.min(shards.length, ACTIVE_SHARDS);
    if (this.activeShardCount === 0) {
      console.warn('ShardRouter: No shards available, will use fallback mode');
    }
  }

  /**
   * FNV-1a hash for consistent shard distribution
   * Same org always maps to same shard
   */
  private hashToShard(orgId: string): number {
    let hash = 2166136261;
    for (let i = 0; i < orgId.length; i++) {
      hash ^= orgId.charCodeAt(i);
      hash = Math.imul(hash, 16777619);
    }
    // Use absolute value and mod by active shards
    return Math.abs(hash) % this.activeShardCount;
  }

  /**
   * Check if sharding is enabled and available
   */
  isEnabled(): boolean {
    return this.activeShardCount > 0;
  }

  /**
   * Compute shard ID for an org without persisting (for routing decisions)
   */
  computeShardId(orgId: string): number {
    return this.hashToShard(orgId);
  }

  /**
   * Get the shard ID for an organization
   */
  async getShardId(orgId: string): Promise<number> {
    // Check cache first
    const cached = this.shardCache.get(orgId);
    if (cached !== undefined) {
      return cached;
    }

    // Check routing table
    const result = await this.centralDb
      .prepare('SELECT shard_id FROM shard_routing WHERE organization_id = ?')
      .bind(orgId)
      .first<{ shard_id: number }>();

    if (result) {
      this.shardCache.set(orgId, result.shard_id);
      return result.shard_id;
    }

    // New org - assign to shard using consistent hash
    const shardId = this.hashToShard(orgId);

    try {
      await this.centralDb
        .prepare(`
          INSERT INTO shard_routing (organization_id, shard_id, created_at)
          VALUES (?, ?, datetime('now'))
        `)
        .bind(orgId, shardId)
        .run();
    } catch (e) {
      // Race condition - another request created it, fetch the actual value
      const retry = await this.centralDb
        .prepare('SELECT shard_id FROM shard_routing WHERE organization_id = ?')
        .bind(orgId)
        .first<{ shard_id: number }>();
      if (retry) {
        this.shardCache.set(orgId, retry.shard_id);
        return retry.shard_id;
      }
    }

    this.shardCache.set(orgId, shardId);
    return shardId;
  }

  /**
   * Get the D1 database for an organization
   */
  async getShardForOrg(orgId: string): Promise<D1Database> {
    if (!this.isEnabled()) {
      throw new Error('Sharding not available - no shard databases configured');
    }

    const shardId = await this.getShardId(orgId);
    const shard = this.shards[shardId];

    if (!shard) {
      throw new Error(`Shard ${shardId} not available for org ${orgId}`);
    }

    return shard;
  }

  /**
   * Get routing info for an organization
   */
  async getRoutingInfo(orgId: string): Promise<ShardRoutingInfo | null> {
    return this.centralDb
      .prepare('SELECT * FROM shard_routing WHERE organization_id = ?')
      .bind(orgId)
      .first<ShardRoutingInfo>();
  }

  /**
   * Mark an organization as migrated to D1
   */
  async markMigrated(orgId: string, stats?: { campaignCount?: number; metricsRowCount?: number }): Promise<void> {
    await this.centralDb
      .prepare(`
        UPDATE shard_routing
        SET migrated_at = datetime('now'),
            campaign_count = COALESCE(?, campaign_count),
            metrics_row_count = COALESCE(?, metrics_row_count)
        WHERE organization_id = ?
      `)
      .bind(stats?.campaignCount ?? null, stats?.metricsRowCount ?? null, orgId)
      .run();
  }

  /**
   * Mark an organization as verified (data integrity checked)
   */
  async markVerified(orgId: string): Promise<void> {
    await this.centralDb
      .prepare(`
        UPDATE shard_routing
        SET verified_at = datetime('now')
        WHERE organization_id = ?
      `)
      .bind(orgId)
      .run();
  }

  /**
   * Check if an organization has been migrated to D1
   */
  async isMigrated(orgId: string): Promise<boolean> {
    const info = await this.getRoutingInfo(orgId);
    return info?.migrated_at !== null;
  }

  /**
   * Execute a query on the correct shard for an organization
   */
  async queryForOrg<T = unknown>(
    orgId: string,
    query: string,
    ...params: unknown[]
  ): Promise<T[]> {
    const shard = await this.getShardForOrg(orgId);
    const result = await shard.prepare(query).bind(...params).all<T>();
    return result.results;
  }

  /**
   * Execute a query that returns a single row
   */
  async queryOneForOrg<T = unknown>(
    orgId: string,
    query: string,
    ...params: unknown[]
  ): Promise<T | null> {
    const shard = await this.getShardForOrg(orgId);
    return shard.prepare(query).bind(...params).first<T>();
  }

  /**
   * Execute a write operation on the correct shard
   */
  async runForOrg(
    orgId: string,
    query: string,
    ...params: unknown[]
  ): Promise<D1Result<unknown>> {
    const shard = await this.getShardForOrg(orgId);
    return shard.prepare(query).bind(...params).run();
  }

  /**
   * Execute a batch of operations on the correct shard
   */
  async batchForOrg(
    orgId: string,
    statements: ReturnType<D1Database['prepare']>[]
  ): Promise<D1Result<unknown>[]> {
    const shard = await this.getShardForOrg(orgId);
    return shard.batch(statements);
  }

  /**
   * Get all organizations assigned to a specific shard
   */
  async getOrgsInShard(shardId: number): Promise<string[]> {
    const result = await this.centralDb
      .prepare('SELECT organization_id FROM shard_routing WHERE shard_id = ?')
      .bind(shardId)
      .all<{ organization_id: string }>();
    return result.results.map((r: { organization_id: string }) => r.organization_id);
  }

  /**
   * Get statistics about shard distribution
   */
  async getShardStats(): Promise<{ shardId: number; orgCount: number; migrated: number; totalSize: number }[]> {
    const result = await this.centralDb
      .prepare(`
        SELECT
          shard_id,
          COUNT(*) as org_count,
          SUM(CASE WHEN migrated_at IS NOT NULL THEN 1 ELSE 0 END) as migrated,
          SUM(COALESCE(data_size_bytes, 0)) as total_size
        FROM shard_routing
        GROUP BY shard_id
        ORDER BY shard_id
      `)
      .all<{ shard_id: number; org_count: number; migrated: number; total_size: number }>();

    return result.results.map((r: { shard_id: number; org_count: number; migrated: number; total_size: number }) => ({
      shardId: r.shard_id,
      orgCount: r.org_count,
      migrated: r.migrated,
      totalSize: r.total_size,
    }));
  }

  /**
   * Clear the cache (useful for testing or after rebalancing)
   */
  clearCache(): void {
    this.shardCache.clear();
  }
}

// Type for D1Result (simplified)
interface D1Result<T> {
  success: boolean;
  results: T[];
  meta: {
    changes: number;
    last_row_id: number;
    duration: number;
  };
}

interface D1PreparedStatement {
  bind(...params: unknown[]): D1PreparedStatement;
  first<T>(): Promise<T | null>;
  all<T>(): Promise<{ results: T[] }>;
  run(): Promise<D1Result<unknown>>;
}
